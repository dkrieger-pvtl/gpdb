-- See src/backend/fts/README for background information

-- This test is for two scenarios:
-- 1) Ensuring fresh results when a probe is requested while a scan is already
-- in progress.

-- 2) Ensuring that when multiple probe requests come in before the start of a
-- new probe, then all those requests share the same result (ie: piggyback).

-- When reasoning about this test, keep in mind that the ftploop is a single process
--  and each fts_notify_probe is in its own separate process(e.g. the backend running
--  that request).

include: helpers/server_helpers.sql;

create extension if not exists gp_inject_fault;
select gp_inject_fault('all', 'reset', 1);

create temp table fts_probe_results(seq serial, current_started int, expected_start_delta int,
                                                current_done int, expected_done_delta int);

-- create extension only on master since the FTS process is only on master
create or replace function fts_probe_stats() returns table (
    fts_probe_started int8,
    fts_probe_done int8,
    fts_statusVersion int2
  )
  as '/@abs_builddir@/../regress/regress.so', 'gp_fts_probe_stats' language c execute on master reads sql data;

create or replace view get_stats as
select
  seq,
  current_started,
  expected_start_delta,
  current_started - min(current_started) over () as actual_start_delta, -- actual_start_delta = current_started - initial_started
  current_done,
  expected_done_delta,
  current_done - min(current_done) over () as actual_done_delta -- actual_done_delta = current_done - initial_done
from fts_probe_results order by seq;

drop function if exists insert_expected_stats(int, int);
create or replace function insert_expected_stats(expected_start_delta int, expected_done_delta int) returns void as $$
  INSERT INTO fts_probe_results (current_started, expected_start_delta, current_done, expected_done_delta) /* inside a function */
  SELECT fts_probe_started AS current_started, /* inside a function */
         expected_start_delta, /* inside a function */
         fts_probe_done AS current_done, /* inside a function */
         expected_done_delta /* inside a function */
  FROM fts_probe_stats(); /* inside a function */
$$ language sql volatile;

-- ensure the internal regular probes do not affect our test
!\retcode gpconfig -c gp_fts_probe_interval -v 3600;
!\retcode gpstop -u;

-- guarantee fts loop is suspended at a known location

-- 5&: select gp_request_fts_probe_scan();
-- select gp_wait_until_triggered_fault('fts_before_probe', 1, 1);

-- start of test...we expect no probes in flight
select insert_expected_stats(0, 0);   -- seq 1 (0,0)
select seq, expected_start_delta, actual_start_delta, expected_done_delta, actual_done_delta from get_stats order by seq desc limit 1;

-- NOTE: fts_notify_before sends any async signal...how to do.
select gp_inject_fault_infinite('fts_notify_before', 'suspend', 1);
select gp_inject_fault_infinite('fts_after_latch', 'suspend', 1);
select gp_inject_fault_infinite('fts_before_probe', 'suspend', 1);
-- start three probe requests and suspend before incrementing the start tick
-- they should all share the same results
1&: select gp_request_fts_probe_scan();
2&: select gp_request_fts_probe_scan();
3&: select gp_request_fts_probe_scan();
select gp_wait_until_triggered_fault('fts_notify_before', 3, 1);

select gp_wait_until_triggered_fault('fts_after_latch', 1, 1);
select gp_inject_fault('fts_after_latch', 'resume', 1);

select gp_wait_until_triggered_fault('fts_before_probe', 1, 1);

select gp_inject_fault('fts_notify_before', 'resume', 1);

-- we stop before incrementing start, so (0,0)
select insert_expected_stats(0, 0);  -- seq 2 (0, 0)
select seq, expected_start_delta, actual_start_delta, expected_done_delta, actual_done_delta from get_stats order by seq desc limit 1;
select gp_inject_fault_infinite('fts_after_probe', 'suspend', 1);
select gp_inject_fault('fts_before_probe', 'resume', 1);
select gp_wait_until_triggered_fault('fts_after_probe', 1, 1);

-- we expect to pass through start once here, since (1,2,3) are piggybacked
select insert_expected_stats(1, 0);  -- seq 3 (1, 0)
select seq, expected_start_delta, actual_start_delta, expected_done_delta, actual_done_delta from get_stats order by seq desc limit 1;



-- request a fourth probe request during an in-progress probe scan
-- this should not be lost and should return with fresh results
select gp_inject_fault('fts_before_probe', 'reset', 1);
select gp_inject_fault_infinite('fts_before_probe', 'suspend', 1);
4&: select gp_request_fts_probe_scan();

select gp_inject_fault('fts_after_probe', 'resume', 1);

1<:
2<:
3<:

select gp_wait_until_triggered_fault('fts_before_probe', 1, 1);
select gp_inject_fault('fts_before_probe', 'resume', 1);

-- we expect to pass through done twice...once from (1,2,3) and the other from (4)
-- we expect to pass through start once more...from (4)
-- we are getting fresh results from (4) because the start tick of (1,2,3) and (4) differ by 1.
select insert_expected_stats(1, 1);  -- seq 4 (2, 2)
select seq, expected_start_delta, actual_start_delta, expected_done_delta, actual_done_delta from get_stats order by seq desc limit 1;

4<:

select insert_expected_stats(2, 2);  -- seq 6 (2, 2)
select seq, expected_start_delta, actual_start_delta, expected_done_delta, actual_done_delta from get_stats order by seq desc limit 1;
select * from get_stats;

-- reset the internal regular probe interval
!\retcode gpconfig -r gp_fts_probe_interval;
!\retcode gpstop -u;
