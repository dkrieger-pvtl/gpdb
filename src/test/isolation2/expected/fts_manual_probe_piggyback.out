-- See src/backend/fts/README for background information
--
-- Piggyback Test
-- Ensure multiple probe requests come in before the start of a new ftsLoop,
-- then all those requests share the same result.
--
-- It is useful to remember that the FtsLoop and each FtsNotifyProbe are
-- individual processes. Careful use of fault injectors are needed to have
-- complete and consistent control over the flow of the two independent
-- processes - the ftsLoop and FtsNotifyProber's.

include: helpers/server_helpers.sql;
CREATE

create extension if not exists gp_inject_fault;
CREATE
select gp_inject_fault('all', 'reset', 1);
 gp_inject_fault 
-----------------
 t               
(1 row)

-- ensure the internal regular probes do not affect our test
!\retcode gpconfig -c gp_fts_probe_interval -v 3600;
-- start_ignore

-- end_ignore
(exited with code 0)
!\retcode gpstop -u;
-- start_ignore

-- end_ignore
(exited with code 0)

-- ensure there is no in progress ftsLoop after reloading the gp_fts_probe_interval
select gp_request_fts_probe_scan();
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)

-- start counting number of probe requests
select gp_inject_fault_infinite('ftsNotify_before', 'skip', 1);
 gp_inject_fault_infinite 
--------------------------
 t                        
(1 row)

-- ensure the ftsLoop is at a known starting location
select gp_inject_fault_infinite('ftsLoop_before_probe', 'suspend', 1);
 gp_inject_fault_infinite 
--------------------------
 t                        
(1 row)
1&: select gp_request_fts_probe_scan();  <waiting ...>
select gp_wait_until_triggered_fault('ftsLoop_before_probe', 1, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 t                             
(1 row)

-- start multiple probes
2&: select gp_request_fts_probe_scan();  <waiting ...>
3&: select gp_request_fts_probe_scan();  <waiting ...>
-- ensure the probe requests start waiting before ftsLoop starts probe
select gp_wait_until_triggered_fault('ftsNotify_before', 3, 1);
 gp_wait_until_triggered_fault 
-------------------------------
 t                             
(1 row)

-- finish the current ftsLoop iteration and pause before starting next iteration
select gp_inject_fault_infinite('ftsLoop_before_wait_latch', 'suspend', 1);
 gp_inject_fault_infinite 
--------------------------
 t                        
(1 row)
select gp_inject_fault('ftsLoop_before_probe', 'resume', 1);
 gp_inject_fault 
-----------------
 t               
(1 row)
-- all three requests should not be blocked by the next iteration
1<:  <... completed>
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)
2<:  <... completed>
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)
3<:  <... completed>
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)

select gp_inject_fault('ftsLoop_before_probe', 'reset', 1);
 gp_inject_fault 
-----------------
 t               
(1 row)
select gp_inject_fault('ftsLoop_before_wait_latch', 'reset', 1);
 gp_inject_fault 
-----------------
 t               
(1 row)
select gp_inject_fault_infinite('ftsNotify_before', 'reset', 1);
 gp_inject_fault_infinite 
--------------------------
 t                        
(1 row)

-- reset the internal regular probe interval
!\retcode gpconfig -r gp_fts_probe_interval;
-- start_ignore

-- end_ignore
(exited with code 0)
!\retcode gpstop -u;
-- start_ignore

-- end_ignore
(exited with code 0)
