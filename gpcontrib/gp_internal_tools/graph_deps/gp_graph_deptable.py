#!/usr/bin/env python
#
# ./gp_graph_deptable.py data/input/deps.txt
# ./gp_graph_deptable.py data/input/deps.txt data/input/deps_add.txt
#
# WARNING: without telling you, this program will NOT overwrite existing files, but display them anyway.  So you should
#  remove all files generated by previous versions of this program first.
#
# Program that converts a specifically formatted text-file(see below) into a pdf graph and a text graph.  It also
# provides basic graph diff'ing functionality.  The basic idea:
#
#  1). if only a single input file is given, create a single graph and end.
#  2). if two input files are given, create two graphs, calculate the set union, set intersection, set differences, and
#             graph the intersection and both differences in a perspicuous way
#
# You'll get these as output for 2).  *.gv is in readable text format; *.pdf is that file rendered
#   AandB.gv
#   AandB.gv.pdf
#   AnotB.gv
#   AnotB.gv.pdf
#   BnotA.gv
#   BnotA.gv.pdf
#   all.gv
#   all.gv.pdf
#
# The vision is to provide a general purpose tool for visualizing postgres catalog tables, either live or as a result
#   of a failed pg_regress test.  It is for the latter reason that we focus on a single graph as our unit of work: we
#   might just have two graphs from two different runs of a test, for instance.
#
# TODO: combine the graphs into a single view with perspicuous differences between the graphs
# TODO: the combining of subgraphs of AandB,BnotA, and AnotB below is not quite right...need to fix...use as an example
#    ./gp_graph_deptable.py data/input/deps.txt data/input/deps_add_default_split.txt
# TODO: generalize the input
# TODO: add diff of graphs to unit test....
#
# dependencies:
#   1). install graphviz on your machine  ('brew install graphviz')
#   2). install the python graphviz ('pip install graphviz')
#   3). install the python graphviz parser('pip install pydot') https://github.com/pydot/pydot
#
# We use graphviz for the rendering, and pydot to parse the resulting dot file.  It's a bit of a hack because neither
# of these provides exactly what we want.  We use graphviz for the layout, and pydot to parse the graphviz format,
# and our own py code where those fall short, or where the documentation for them is lacking.

# This is a hack designed to visualize the new tests added in
#  https://github.com/greenplum-db/gpdb/pull/7047
#
# The input assumptions are quite implementation-defined but here's an example:

# r_1_prt_r2_r_key_r_name_key | i         | r_r_key_r_name_key          | i            | pg_class      |        0 | pg_class      |           0 | I
# r_1_prt_r1_r_key_r_name_key | i         | r_r_key_r_name_key          | i            | pg_class      |        0 | pg_class      |           0 | I
# r_r_key_r_name_key          | i         | r_r_key_r_name_key          | u            | pg_class      |        0 | pg_constraint |           0 | i
# r_1_prt_r1_r_key_r_name_key | i         | r_1_prt_r1_r_key_r_name_key | u            | pg_class      |        0 | pg_constraint |           0 | i
# r_1_prt_r2_r_key_r_name_key | i         | r_1_prt_r2_r_key_r_name_key | u            | pg_class      |        0 | pg_constraint |           0 | i
# r_1_prt_r2_r_key_r_name_key | u         | r_1_prt_r2                  | r            | pg_constraint |        0 | pg_class      |           2 | a
# r_r_key_r_name_key          | u         | r                           | r            | pg_constraint |        0 | pg_class      |           1 | a
# r_r_key_r_name_key          | u         | r                           | r            | pg_constraint |        0 | pg_class      |           2 | a
# r_1_prt_r2_r_key_r_name_key | u         | r_1_prt_r2                  | r            | pg_constraint |        0 | pg_class      |           1 | a
# r_1_prt_r1_r_key_r_name_key | u         | r_1_prt_r1                  | r            | pg_constraint |        0 | pg_class      |           2 | a
# r_1_prt_r1_r_key_r_name_key | u         | r_1_prt_r1                  | r            | pg_constraint |        0 | pg_class      |           1 | a
# r_1_prt_r1_r_key_r_name_key | u         | r_r_key_r_name_key          | u            | pg_constraint |        0 | pg_constraint |           0 | I
# r_1_prt_r2_r_key_r_name_key | u         | r_r_key_r_name_key          | u            | pg_constraint |        0 | pg_constraint |           0 | I


from __future__ import print_function
import argparse
from os import path
from graphviz import Digraph
import pydot
import sys

#  short snipped for graphvis for reference
#
#   dot = Digraph(comment='The Round Table')
#
#   dot  #doctest: +ELLIPSIS
#
#   dot.node('A', 'King Arthur')
#   dot.node('B', 'Sir Bedevere the Wise')
#   dot.node('L', 'Sir Lancelot the Brave')
#
#   dot.edges(['AB', 'AL'])
#   dot.edge('B', 'L', constraint='false')
#
#   print(dot.source)  # doctest: +NORMALIZE_WHITESPACE
#
#   dot.render('test-output/round-table.gv', view=True)

# using pydot, parse the graphviz dot format for the two graphs(lhs/rhs) and return the (node,edge)
#  from various set operations between the two
class SetDifferenceTwoDigraphs:
    def __init__(self, lhs, rhs):
        self.lhs = origDot
        self.rhs = newDot
        (lhsPydotGraph,) = pydot.graph_from_dot_data(lhs.source)
        (rhsPydotGraph,) = pydot.graph_from_dot_data(rhs.source)
        self.lhsPydotEdges = lhsPydotGraph.get_edges()
        self.rhsPydotEdges = rhsPydotGraph.get_edges()
        self.lhsPydotNodes = lhsPydotGraph.get_nodes()
        self.rhsPydotNodes = rhsPydotGraph.get_nodes()

        self.lhsEdgeSet = set([])
        for edge in self.lhsPydotEdges:
            self.lhsEdgeSet.add(edge)

        self.rhsEdgeSet = set([])
        for edge in self.rhsPydotEdges:
            self.rhsEdgeSet.add(edge)

        self.lhsNodeSet = set([])
        for node in self.lhsPydotNodes:
            self.lhsNodeSet.add(node)

        self.rhsNodeSet = set([])
        for node in self.rhsPydotNodes:
            self.rhsNodeSet.add(node)

        # for edge in self.lhsEdgeSet:
        #     print("E:" + str(edge) + "\nS:\n" + edge.get_source() + "\nD:\n" + edge.get_destination() +  "\nA:\n" + str(edge.get_attributes()))
        #
        # for node in self.lhsNodeSet:
        #     print("N:" + str(node) + "\nN:\n" + node.get_name() + "\nA:\n", node.get_attributes())

    def AorB(self):
        nodes = set([])
        edges = set([])
        for node in self.lhsNodeSet:
            nodes.add(node)
        for node in self.rhsNodeSet:
            nodes.add(node)
        for edge in self.lhsEdgeSet:
            edges.add(edge)
        for edge in self.rhsEdgeSet:
            edges.add(edge)

        return self.lhsNodeSet.union(self.rhsNodeSet), self.lhsEdgeSet.union(self.rhsEdgeSet)

    def AandB(self):
        nodes = set([])
        edges = set([])
        for lhsNode in self.lhsNodeSet:
            lhsSource = lhsNode.get_name()
            lhsAttributes = lhsNode.get_attributes()
            for rhsNode in self.rhsNodeSet:
                rhsSource = rhsNode.get_name()
                rhsAttributes = rhsNode.get_attributes()
                if lhsSource == rhsSource:
                    nodes.add(lhsNode)
                    for attr in lhsAttributes:
                        if attr not in rhsAttributes:
                            print("warning: node: " + lhsSource + " has attribute " + attr + " in one graph and not other...ignoring")
                        elif lhsAttributes[attr] != rhsAttributes[attr]:
                            print("warning: node: " + lhsSource + " has attribute " + lhsAttributes[attr] + " but other side has " + rhsAttributes[attr])
                    break
        for lhsEdge in self.lhsEdgeSet:
            lhsSource = lhsEdge.get_source()
            lhsDestination = lhsEdge.get_destination()
            lhsAttributes = lhsEdge.get_attributes()
            for rhsEdge in self.rhsEdgeSet:
                rhsSource = rhsEdge.get_source()
                rhsDestination = rhsEdge.get_destination()
                rhsAttributes = rhsEdge.get_attributes()
                if (lhsSource == rhsSource) and (lhsDestination == rhsDestination):
                    edges.add(lhsEdge)
                    # for attr in lhsAttributes:
                    #     if attr not in rhsAttributes:
                    #         print("warning: edge (" + lhsSource + "," + lhsDestination + ") has attribute " + attr + " in one graph and not other...ignoring")
                    #     elif lhsAttributes[attr] != rhsAttributes[attr]:
                    #         print("warning: node: " + lhsSource + " has attribute " + lhsAttributes[attr] + " but other side has " + rhsAttributes[attr])
                    break
        return nodes, edges

    @staticmethod
    def setDifference(lhsNodeSet, lhsEdgeSet, rhsNodeSet, rhsEdgeSet):
        nodes = set([])
        edges = set([])
        for lhsNode in lhsNodeSet:
            lhsSource = lhsNode.get_name()
            lhsAttributes = lhsNode.get_attributes()
            shouldAdd = True
            for rhsNode in rhsNodeSet:
                rhsSource = rhsNode.get_name()
                rhsAttributes = rhsNode.get_attributes()
                if lhsSource == rhsSource:
                    shouldAdd = False
                    break
            if shouldAdd:
                nodes.add(lhsNode)
                # for attr in lhsAttributes:
                # if attr not in rhsAttributes:
                #     print("warning: node: " + lhsSource + " has attribute " + attr + " in one graph and not other...ignoring")
                # elif lhsAttributes[attr] != rhsAttributes[attr]:
                #     print("warning: node: " + lhsSource + " has attribute " + lhsAttributes[attr] + " but other side has " + rhsAttributes[attr])

        for lhsEdge in lhsEdgeSet:
            lhsSource = lhsEdge.get_source()
            lhsDestination = lhsEdge.get_destination()
            lhsAttributes = lhsEdge.get_attributes()
            shouldAdd = True
            for rhsEdge in rhsEdgeSet:
                rhsSource = rhsEdge.get_source()
                rhsDestination = rhsEdge.get_destination()
                rhsAttributes = rhsEdge.get_attributes()
                if (lhsSource == rhsSource) and (lhsDestination == rhsDestination):
                    shouldAdd = False
                    break
            if shouldAdd:
                edges.add(lhsEdge)
                #for attr in lhsAttributes:
                    # if attr not in rhsAttributes:
                    #     print("warning: edge (" + lhsSource + "," + lhsDestination + ") has attribute " + attr + " in one graph and not other...ignoring")
                    # elif lhsAttributes[attr] != rhsAttributes[attr]:
                    #     print("warning: node: " + lhsSource + " has attribute " + lhsAttributes[attr] + " but other side has " + rhsAttributes[attr])

        return nodes, edges

    def AnotB(self):
        return SetDifferenceTwoDigraphs.setDifference(self.lhsNodeSet, self.lhsEdgeSet, self.rhsNodeSet, self.rhsEdgeSet)
    def BnotA(self):
        return SetDifferenceTwoDigraphs.setDifference(self.rhsNodeSet, self.rhsEdgeSet, self.lhsNodeSet, self.lhsEdgeSet)


# from the given pydot file, construct a dot graph from it.  See above
def MakeDigraphFromPydot(graphName, nodesAndEdges, fillColor='white'):
    dot = Digraph(comment=graphName,name=graphName)
    (node,edge) = nodesAndEdges
    nodeList = {}

    for e in edge:
        attrs = {}
        attrs['color'] = 'black'
        for key in e.obj_dict['attributes']:
            attrs[key] = e.obj_dict['attributes'][key]
        nodeList[e.get_source()] = True
        nodeList[e.get_destination()] = True
        dot.edge(e.get_source(),e.get_destination(), attrs['label'], color=attrs['color'])

    for n in node:
        attrs = {}
        attrs['color'] = 'black'
        attrs['shape'] = 'rectangle'
        for key in n.obj_dict['attributes']:
            attrs[key] = n.obj_dict['attributes'][key]
        if n.get_name() in nodeList:  # exclude all nodes that don't participate in an edge
            dot.node(n.get_name(), color=attrs['color'], shape=attrs['shape'], fillcolor=fillColor, style="filled")


    return dot

# IN: a fileName in the pre-defined format above
# OUT: (Digraph populated from fileName, set with head/tail of Digraph)
def MakeDigraphFromFile(fileName):

    infile = open(fileName,'r')

    dot = Digraph(comment=fileName)

    for line in infile:
        # depname, classtype, refname, refclasstype, classid, objsubid, refclassid, refobjsubid,deptype = line.rstrip().split('|')
        print(line.rstrip())
        elements = []
        for element in line.strip().split('|'):
            elements.append(element.strip())
        depNode = elements[0] + '(' + elements[1] + '_' + elements[5] + ')'
        refNode = elements[2] + '(' + elements[3] + '_' + elements[7] + ')'
        depType = elements[8]
        # print(depNode,refNode,depType)
        dot.node(depNode, shape=getNodeShape(elements[1]), color=getNodeOutlineColor(elements[1]))
        dot.node(refNode, shape=getNodeShape(elements[3]), color=getNodeOutlineColor(elements[3]))
        dot.edge(depNode, refNode, depType, color=getEdgeColor(depType))

    return (dot)

def getNodeShape(type):
    if type == 'i':
        return 'rarrow'
    elif type == 'r':
        return 'rectangle'
    elif type == 'u':
        return 'ellipse'
    else:
        return 'star'

def getNodeOutlineColor(type):
    if type == 'i':
        return 'green'
    elif type == 'r':
        return 'black'
    elif type == 'u':
        return 'orange'
    else:
        return 'orange'

def getEdgeColor(type):
    if type == 'i':
        return 'green'
    elif type == 'I':
        return 'orange'
    elif type == 'a':
        return 'black'
    else:
        return 'red'

def setupArguments(options):
    argsp = argparse.ArgumentParser(description="postgresQL dependency table parsing description")
    argsp.add_argument('-o', '--origFile', type=str, nargs=1, required=True, help='first(perhaps only) graph to render')
    argsp.add_argument('-n', '--newFile', type=str, nargs=1, required=False, help='second graph to render; will show deltas from first graph')
    argsp.add_argument('-d', '--outputDir', type=str, nargs=1, required=False, help='output directory to save graphviz and pdf files')

    ns = argsp.parse_args(options)
    print("ARGUMENTS:" + str(ns))
    return ns


config = setupArguments(sys.argv[1:])

# parse the input args
origFile = config.origFile[0]
newFile = config.newFile[0] if config.newFile else None
outputDir = config.outputDir[0] if config.outputDir else ''

# FIRST GRAPH
(origDot) = MakeDigraphFromFile(origFile)
origSource = origDot.source
print("origSource: " + origSource)
origDot.render(path.normpath(path.join(outputDir, path.basename(origFile) + '.gv')), view=True)


# SECOND GRAPH
if not newFile:
    print("Only one infile given...no diff needed")
    sys.exit(0)

(newDot) = MakeDigraphFromFile(newFile)
print(newDot.source)
newDot.render(path.normpath(path.join(outputDir, path.basename(newFile) + '.gv')), view=True)

deltaGraph = SetDifferenceTwoDigraphs(origDot, newDot)

dotAandB = MakeDigraphFromPydot('AandB', deltaGraph.AandB())
dotAandB.render('AandB' + '.gv', view=True)

dotBnotA = MakeDigraphFromPydot('BnotA', deltaGraph.BnotA(), 'green')
dotBnotA.render('BnotA' + '.gv', view=True)

dotAnotB = MakeDigraphFromPydot('AnotB', deltaGraph.AnotB(), 'red')
dotAnotB.render('AnotB' + '.gv', view=True)

dotAll = Digraph(comment='all')
dotAll.subgraph(dotAandB)
dotAll.subgraph(dotBnotA)
dotAll.subgraph(dotAnotB)
dotAll.render(path.normpath(path.join(outputDir, path.basename(origFile) + "_diff_" + path.basename(newFile) + '.gv')), view=True)