#!/usr/bin/env python
#
# ./gp_graph_deptable.py data/input/deps.txt
# ./gp_graph_deptable.py data/input/deps.txt data/input/deps_add.txt
#
# WARNING: without telling you, this program will NOT overwrite existing files, but display them anyway.  So you should
#  remove all files generated by previous versions of this program first.
#
# Program that converts a specifically formatted text-file(see below) into a pdf graph and a text graph.  It also
# provides basic graph diff'ing functionality.  The basic idea:
#
#  1). if only a single input file is given, create a single graph and end.
#  2). if two input files are given, create two graphs, calculate the set union, set intersection, set differences, and
#             graph the intersection and both differences in a perspicuous way
#
# You'll get these as output for 2).  *.gv is in readable text format; *.pdf is that file rendered
#   AandB.gv
#   AandB.gv.pdf
#   AnotB.gv
#   AnotB.gv.pdf
#   BnotA.gv
#   BnotA.gv.pdf
#   all.gv
#   all.gv.pdf
#
# The vision is to provide a general purpose tool for visualizing postgres catalog tables, either live or as a result
#   of a failed pg_regress test.  It is for the latter reason that we focus on a single graph as our unit of work: we
#   might just have two graphs from two different runs of a test, for instance.
#
# TODO: combine the graphs into a single view with perspicuous differences between the graphs
# TODO: the combining of subgraphs of AandB,BnotA, and AnotB below is not quite right...need to fix...use as an example
#    ./gp_graph_deptable.py data/input/deps.txt data/input/deps_add_default_split.txt
# TODO: generalize the input
#
# dependencies:
#   1). install graphviz on your machine  ('brew install graphviz')
#   2). install the python graphviz ('pip install graphviz')
#   3). install the python graphviz parser('pip install pydot') https://github.com/pydot/pydot
#
# We use graphviz for the rendering, and pydot to parse the resulting dot file.  It's a bit of a hack because neither
# of these provides exactly what we want.  We use graphviz for the layout, and pydot to parse the graphviz format,
# and our own py code where those fall short, or where the documentation for them is lacking.

# This is a hack designed to visualize the new tests added in
#  https://github.com/greenplum-db/gpdb/pull/7047
#
# The input assumptions are quite implementation-defined but here's an example:

# r_1_prt_r2_r_key_r_name_key | i         | r_r_key_r_name_key          | i            | pg_class      |        0 | pg_class      |           0 | I
# r_1_prt_r1_r_key_r_name_key | i         | r_r_key_r_name_key          | i            | pg_class      |        0 | pg_class      |           0 | I
# r_r_key_r_name_key          | i         | r_r_key_r_name_key          | u            | pg_class      |        0 | pg_constraint |           0 | i
# r_1_prt_r1_r_key_r_name_key | i         | r_1_prt_r1_r_key_r_name_key | u            | pg_class      |        0 | pg_constraint |           0 | i
# r_1_prt_r2_r_key_r_name_key | i         | r_1_prt_r2_r_key_r_name_key | u            | pg_class      |        0 | pg_constraint |           0 | i
# r_1_prt_r2_r_key_r_name_key | u         | r_1_prt_r2                  | r            | pg_constraint |        0 | pg_class      |           2 | a
# r_r_key_r_name_key          | u         | r                           | r            | pg_constraint |        0 | pg_class      |           1 | a
# r_r_key_r_name_key          | u         | r                           | r            | pg_constraint |        0 | pg_class      |           2 | a
# r_1_prt_r2_r_key_r_name_key | u         | r_1_prt_r2                  | r            | pg_constraint |        0 | pg_class      |           1 | a
# r_1_prt_r1_r_key_r_name_key | u         | r_1_prt_r1                  | r            | pg_constraint |        0 | pg_class      |           2 | a
# r_1_prt_r1_r_key_r_name_key | u         | r_1_prt_r1                  | r            | pg_constraint |        0 | pg_class      |           1 | a
# r_1_prt_r1_r_key_r_name_key | u         | r_r_key_r_name_key          | u            | pg_constraint |        0 | pg_constraint |           0 | I
# r_1_prt_r2_r_key_r_name_key | u         | r_r_key_r_name_key          | u            | pg_constraint |        0 | pg_constraint |           0 | I

#

from __future__ import print_function
from graphviz import Digraph
import pydot
import sys

#  short snipped for graphvis for reference
#
#   dot = Digraph(comment='The Round Table')
#
#   dot  #doctest: +ELLIPSIS
#
#   dot.node('A', 'King Arthur')
#   dot.node('B', 'Sir Bedevere the Wise')
#   dot.node('L', 'Sir Lancelot the Brave')
#
#   dot.edges(['AB', 'AL'])
#   dot.edge('B', 'L', constraint='false')
#
#   print(dot.source)  # doctest: +NORMALIZE_WHITESPACE
#
#   dot.render('test-output/round-table.gv', view=True)

# parse the input args
infile1 = ""
infile2 = ""
if len(sys.argv) < 2:
    sys.exit("Usage: gp_graph_deptable.py infile1.txt [infile2.txt]")
elif len(sys.argv) == 2:
    infile1 = sys.argv[1]
elif len(sys.argv) == 3:
    infile1 = sys.argv[1]
    infile2 = sys.argv[2]
else:
    sys.exit("Usage: gp_graph_deptable.py infile1.txt [infile2.txt]")

# using pydot, parse the graphviz dot format for the two graphs(lhs/rhs) and return the (node,edge)
#  from various set operations between the two
class SetDifferenceTwoDigraphs:
    def __init__(self, lhs, rhs):
        self.lhs = dot1
        self.rhs = dot2
        (lhsPydotGraph,) = pydot.graph_from_dot_data(lhs.source)
        (rhsPydotGraph,) = pydot.graph_from_dot_data(rhs.source)
        self.lhsPydotEdges = lhsPydotGraph.get_edges()
        self.rhsPydotEdges = rhsPydotGraph.get_edges()
        self.lhsPydotNodes = lhsPydotGraph.get_nodes()
        self.rhsPydotNodes = rhsPydotGraph.get_nodes()

        self.lhsEdgeSet = set([])
        for edge in self.lhsPydotEdges:
            self.lhsEdgeSet.add(edge)

        self.rhsEdgeSet = set([])
        for edge in self.rhsPydotEdges:
            self.rhsEdgeSet.add(edge)

        self.lhsNodeSet = set([])
        for node in self.lhsPydotNodes:
            self.lhsNodeSet.add(node)

        self.rhsNodeSet = set([])
        for node in self.rhsPydotNodes:
            self.rhsNodeSet.add(node)

    def AorB(self):
        return (self.lhsNodeSet.union(self.rhsNodeSet), self.lhsEdgeSet.union(self.rhsEdgeSet))
    def AandB(self):
        return (self.lhsNodeSet, self.lhsEdgeSet.intersection(self.rhsEdgeSet))
    def AnotB(self):
        return (self.lhsNodeSet - self.rhsNodeSet, self.lhsEdgeSet - self.rhsEdgeSet)
    def BnotA(self):
        return (self.rhsNodeSet - self.lhsNodeSet, self.rhsEdgeSet - self.lhsEdgeSet)

# from the given pydot file, construct a dot graph from it.  See above
def MakeDigraphFromPydot(graphName, nodesAndEdges, fillColor='white'):
    dot = Digraph(comment=graphName,name=graphName)
    (node,edge) = nodesAndEdges
    nodeList = {}

    for e in edge:
        attrs = {}
        attrs['color'] = 'black'
        for key in e.obj_dict['attributes']:
            attrs[key] = e.obj_dict['attributes'][key]
        nodeList[e.get_source()] = True
        nodeList[e.get_destination()] = True
        dot.edge(e.get_source(),e.get_destination(), attrs['label'], color=attrs['color'])

    for n in node:
        attrs = {}
        attrs['color'] = 'black'
        attrs['shape'] = 'rectangle'
        for key in n.obj_dict['attributes']:
            attrs[key] = n.obj_dict['attributes'][key]
        if n.get_name() in nodeList:  # exclude all nodes that don't participate in an edge
            dot.node(n.get_name(), color=attrs['color'], shape=attrs['shape'], fillcolor=fillColor, style="filled")


    return dot

# IN: a fileName in the pre-defined format above
# OUT: (Digraph populated from fileName, set with head/tail of Digraph)
def MakeDigraphFromFile(fileName):

    infile = open(fileName,'r')

    dot = Digraph(comment=fileName)

    for line in infile:
        # depname, classtype, refname, refclasstype, classid, objsubid, refclassid, refobjsubid,deptype = line.rstrip().split('|')
        print(line.rstrip())
        elements = []
        for element in line.strip().split('|'):
            elements.append(element.strip())
        depNode = elements[0] + '(' + elements[1] + '_' + elements[5] + ')'
        refNode = elements[2] + '(' + elements[3] + '_' + elements[7] + ')'
        depType = elements[8]
        # print(depNode,refNode,depType)
        dot.node(depNode, shape=getNodeShape(elements[1]), color=getNodeOutlineColor(elements[1]))
        dot.node(refNode, shape=getNodeShape(elements[3]), color=getNodeOutlineColor(elements[3]))
        dot.edge(depNode, refNode, depType, color=getEdgeColor(depType))

    return (dot)

def getNodeShape(type):
    if (type == 'i'):
        return 'rarrow'
    elif (type == 'r'):
        return 'rectangle'
    elif (type == 'u'):
        return 'ellipse'
    else:
        return 'star'

def getNodeOutlineColor(type):
    if (type == 'i'):
        return 'green'
    elif (type == 'r'):
        return 'black'
    elif (type == 'u'):
        return 'orange'
    else:
        return 'orange'

def getEdgeColor(type):
    if (type == 'i'):
        return 'green'
    elif (type == 'I'):
        return 'orange'
    elif (type == 'a'):
        return 'black'
    else:
        return 'red'    

# FIRST GRAPH
(dot1) = MakeDigraphFromFile(infile1)
s1 = dot1.source
print("S1: " + s1)
dot1.render(infile1 + '.gv', view=True)

# SECOND GRAPH
if (infile2 == ""):
    print("Only one infile given...no diff needed")
    sys.exit(0)

(dot2) = MakeDigraphFromFile(infile2)
print(dot2.source)
dot2.render(infile2 + '.gv', view=True)

deltaGraph = SetDifferenceTwoDigraphs(dot1,dot2)

dotAandB = MakeDigraphFromPydot('AandB', deltaGraph.AandB())
dotAandB.render('AandB' + '.gv', view=True)

dotBnotA = MakeDigraphFromPydot('BnotA', deltaGraph.BnotA(), 'green')
dotBnotA.render('BnotA' + '.gv', view=True)

dotAnotB = MakeDigraphFromPydot('AnotB', deltaGraph.AnotB(), 'red')
dotAnotB.render('AnotB' + '.gv', view=True)

dotAll = Digraph(comment='all')
dotAll.subgraph(dotAandB)
dotAll.subgraph(dotBnotA)
dotAll.subgraph(dotAnotB)
dotAll.render('all' + '.gv', view=True)